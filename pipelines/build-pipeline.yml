trigger:
- main

pool:
  name: 'Projet2CLD'

variables:
  ServiceBusConnectionString: ''

steps:
# Étape 1 (Build) : Installer le SDK .NET 8.x
- task: UseDotNet@2
  displayName: 'Installer .NET SDK 8.x'
  inputs:
    packageType: 'sdk'
    version: '8.0.100'

# Étape 2 (Build) : Restaurer les dépendances
- script: |
    dotnet restore
  workingDirectory: './azure-functions'
  displayName: 'Restaurer les dépendances'

# Étape 2.1 (Build) : Lister les dépendances NuGet
- script: |
    dotnet list package
  workingDirectory: './azure-functions'
  displayName: 'Lister les dépendances NuGet'

# Étape 3 (Build) : Compiler le projet
- script: |
    dotnet build -c Release
  workingDirectory: './azure-functions'
  displayName: 'Compiler le projet'

# Étape 4 (Build) : Publier le projet
- script: |
    dotnet publish -c Release -o ./publishs
  workingDirectory: './azure-functions'
  displayName: 'Publier le projet'

# Étape 4.2 : Vérifier les fichiers publiés
- script: |
    echo "Répertoire actuel : $(System.DefaultWorkingDirectory)"
    echo "Contenu du répertoire azure-functions :"
    dir "$(System.DefaultWorkingDirectory)\azure-functions"
    echo "Contenu du répertoire publishs :"
    dir "$(System.DefaultWorkingDirectory)\azure-functions\publishs"
  displayName: 'Vérifier les fichiers publiés'


# Étape 5 (Build) : Archiver le package publié
- task: ArchiveFiles@2
  displayName: 'Archiver les fichiers publiés'
  inputs:
    rootFolderOrFile: '$(System.DefaultWorkingDirectory)/azure-functions/publishs'
    archiveFile: '$(Build.ArtifactStagingDirectory)/azure-functions.zip'
    archiveType: 'zip'

# Étape 5.1 : Vérifier le contenu du package ZIP
- script: |
    echo "Vérification du contenu du fichier azure-functions.zip"
    tar -tf $(Build.ArtifactStagingDirectory)/azure-functions.zip
  displayName: 'Vérifier le contenu du package ZIP'

# Étape 6 (Build) : Publier l’artefact de build
- task: PublishBuildArtifacts@1
  displayName: 'Publier l’artefact'
  inputs:
    pathToPublish: '$(Build.ArtifactStagingDirectory)'
    artifactName: 'FunctionApp'

# Étape 7 (Deploy) : Déployer le Blob Storage
- task: AzureResourceManagerTemplateDeployment@3
  displayName: 'Déployer le Blob Storage'
  inputs:
    azureResourceManagerConnection: 'AzureConnectionSub1'
    resourceGroupName: 'Projet-2'
    location: 'canadacentral'
    templateLocation: 'Linked artifact'
    csmFile: 'infra/azuredeploy-storage.json'
    csmParametersFile: 'infra/parameters-storage.json'

# Étape 8 (Deploy) : Déployer le Service Bus
- task: AzureResourceManagerTemplateDeployment@3
  displayName: 'Déployer le Service Bus'
  inputs:
    azureResourceManagerConnection: 'AzureConnectionSub1'
    resourceGroupName: 'Projet-2'
    location: 'canadacentral'
    templateLocation: 'Linked artifact'
    csmFile: 'infra/azuredeploy-servicebus.json'
    csmParametersFile: 'infra/parameters-servicebus.json'

# Étape 9 : Attente après le déploiement du Service Bus
- task: PowerShell@2
  displayName: 'Attente de la disponibilité du Service Bus'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Attente de 30 secondes pour la disponibilité du Service Bus..."
      Start-Sleep -Seconds 30

# Étape 10 : Vérifier l'existence du Service Bus
- task: AzureCLI@2
  displayName: 'Vérifier l’existence du Service Bus'
  inputs:
    azureSubscription: 'AzureConnectionSub1'
    scriptType: 'ps'
    scriptLocation: 'inlineScript'
    inlineScript: |
      az servicebus namespace show `
        --resource-group 'Projet-2' `
        --name 'AzureBus-TMEB'

# Étape 11 (Deploy) : Récupérer la clé de connexion Service Bus
- task: AzureCLI@2
  displayName: 'Récupérer la clé de connexion Service Bus'
  inputs:
    azureSubscription: 'AzureConnectionSub1'
    scriptType: 'ps'
    scriptLocation: 'inlineScript'
    inlineScript: |
      $CONNECTION_STRING = az servicebus namespace authorization-rule keys list `
        --resource-group 'Projet-2' `
        --namespace-name 'AzureBus-TMEB' `
        --name 'RootManageSharedAccessKey' `
        --query 'primaryConnectionString' -o tsv
      Write-Host "##vso[task.setvariable variable=ServiceBusConnectionString]$CONNECTION_STRING"
  condition: succeeded()

# Étape 12 (Deploy) : Déployer la Function App
- task: AzureResourceManagerTemplateDeployment@3
  displayName: 'Déployer la Function App'
  inputs:
    azureResourceManagerConnection: 'AzureConnectionSub1'
    resourceGroupName: 'Projet-2'
    location: 'canadacentral'
    templateLocation: 'Linked artifact'
    csmFile: 'infra/azuredeploy-function.json'
    csmParametersFile: 'infra/parameters-function.json'
    overrideParameters: >
      -serviceBusConnectionString "$(ServiceBusConnectionString)"

# Etape 13 (Deploy) : Déployer les fonctions
- task: AzureFunctionApp@1
  inputs:
    azureSubscription: 'AzureConnectionSub1'
    appType: 'functionApp'
    appName: 'FunctionAppProjet2'
    package: '$(System.DefaultWorkingDirectory)/azure-functions.zip'

# Étape 13 (Deploy) : Vérification finale
- script: |
    echo "Clé Service Bus utilisée : $(ServiceBusConnectionString)"
    echo "Déploiement terminé avec succès."
  displayName: 'Vérification finale'
